import tkinter as tk
from tkinter import ttk, messagebox
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
import numpy as np
from sympy import symbols, diff, simplify, nsolve, Eq, log as ln, Min, Max, sqrt, sin, cos, tan, exp, pi, sympify, Add, Mul, Pow, S, Abs
import re

class ConsumerTheoryApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Teoría del Consumidor - Restricciones y Preferencias")
        self.root.geometry("1300x900")
        
        # Notebook principal
        self.main_notebook = ttk.Notebook(root)
        self.main_notebook.pack(fill='both', expand=True)
        
        # Pestañas principales
        self.create_theory_tab()
        self.create_interactive_tab()
    
    def create_theory_tab(self):
        """Pestaña con la teoría y ejemplos"""
        tab = ttk.Frame(self.main_notebook)
        self.main_notebook.add(tab, text="Teoría y Ejemplos")
        
        # Sub-pestañas dentro de la pestaña teórica
        theory_notebook = ttk.Notebook(tab)
        theory_notebook.pack(fill='both', expand=True)
        
        # Crear las sub-pestañas teóricas
        self.create_budget_constraint_tab(theory_notebook)
        self.create_preferences_tab(theory_notebook)
        self.create_indifference_curves_tab(theory_notebook)
        self.create_mrs_tab(theory_notebook)
        self.create_special_cases_tab(theory_notebook)
        self.create_utility_functions_tab(theory_notebook)
    
    def create_budget_constraint_tab(self, notebook):
        """Pestaña sobre restricción presupuestaria"""
        tab = ttk.Frame(notebook)
        notebook.add(tab, text="Restricción Presupuestaria")
        
        # Contenido teórico
        text = tk.Text(tab, wrap=tk.WORD, padx=10, pady=10)
        text.pack(fill='both', expand=True)
        
        content = """
TEORÍA DE LAS RESTRICCIONES PRESUPUESTARIAS

La restricción presupuestaria representa todas las combinaciones de bienes que un consumidor puede adquirir 
dado su ingreso y los precios de los bienes.

Ecuación básica:
p₁x₁ + p₂x₂ = m

Donde:
- p₁, p₂: precios de los bienes 1 y 2
- x₁, x₂: cantidades consumidas de los bienes 1 y 2
- m: ingreso disponible

La pendiente de la recta presupuestaria es -p₁/p₂, que representa el costo de oportunidad de un bien en términos del otro.
"""
        text.insert(tk.END, content)
        text.config(state=tk.DISABLED)
        
        # Gráfico de ejemplo
        fig, ax = plt.subplots(figsize=(6, 4))
        x = np.linspace(0, 100, 100)
        y = 50 - 0.5*x  # Ejemplo con m=100, p1=1, p2=2
        
        ax.plot(x, y, 'b-', label='Recta presupuestaria')
        ax.fill_between(x, 0, y, alpha=0.2, label='Conjunto presupuestario')
        ax.set_xlabel('Bien 1 (x₁)')
        ax.set_ylabel('Bien 2 (x₂)')
        ax.set_title('Representación Gráfica')
        ax.legend()
        ax.grid(True)
        
        canvas = FigureCanvasTkAgg(fig, master=tab)
        canvas.draw()
        canvas.get_tk_widget().pack(side=tk.BOTTOM, fill=tk.BOTH, expand=True)
    
    def create_preferences_tab(self, notebook):
        """Pestaña sobre preferencias del consumidor"""
        tab = ttk.Frame(notebook)
        notebook.add(tab, text="Preferencias")
        
        text = tk.Text(tab, wrap=tk.WORD, padx=10, pady=10)
        text.pack(fill='both', expand=True)
        
        content = """
SUPUESTOS SOBRE LAS PREFERENCIAS

1. Completitud: Puede comparar todas las cestas
2. Reflexividad: Toda cesta es al menos tan buena como sí misma
3. Transitividad: Consistencia en preferencias
4. No saciabilidad local: Prefiere más a menos
5. Convexidad: Prefiere variedad a extremos

Ejemplo de cestas:
| Cesta | Alimentos | Vestido |
|-------|-----------|---------|
| A     | 20        | 30      |
| B     | 10        | 50      |
| C     | 40        | 20      |
"""
        text.insert(tk.END, content)
        text.config(state=tk.DISABLED)
        
        # Gráfico de ejemplo
        fig, ax = plt.subplots(figsize=(6, 4))
        cestas = {'A': (20, 30), 'B': (10, 50), 'C': (40, 20)}
        
        for cesta, coord in cestas.items():
            ax.scatter(coord[0], coord[1], label=f'Cesta {cesta}')
            ax.annotate(cesta, (coord[0]+1, coord[1]+1))
        
        ax.set_xlabel('Alimentos')
        ax.set_ylabel('Vestido')
        ax.set_title('Ejemplo de Cestas de Mercado')
        ax.legend()
        ax.grid(True)
        
        canvas = FigureCanvasTkAgg(fig, master=tab)
        canvas.draw()
        canvas.get_tk_widget().pack(side=tk.BOTTOM, fill=tk.BOTH, expand=True)
    
    def create_indifference_curves_tab(self, notebook):
        """Pestaña sobre curvas de indiferencia"""
        tab = ttk.Frame(notebook)
        notebook.add(tab, text="Curvas de Indiferencia")
        
        text = tk.Text(tab, wrap=tk.WORD, padx=10, pady=10)
        text.pack(fill='both', expand=True)
        
        content = """
CURVAS DE INDIFERENCIA

Representan combinaciones de bienes con igual utilidad.

Propiedades:
1. Pendiente negativa
2. No se cruzan
3. Convexas al origen
4. Mayor distancia = mayor utilidad

Ejemplo con U = A*V:
- U1 = 600 (pasa por (20,30))
- U2 = 1000 (mayor utilidad)
- U3 = 300 (menor utilidad)
"""
        text.insert(tk.END, content)
        text.config(state=tk.DISABLED)
        
        # Gráfico de ejemplo
        fig, ax = plt.subplots(figsize=(6, 4))
        A = np.linspace(1, 50, 100)
        
        # Tres niveles de utilidad
        ax.plot(A, 600/A, 'b-', label='U1 (600)')
        ax.plot(A, 1000/A, 'g--', label='U2 (1000)')
        ax.plot(A, 300/A, 'r-.', label='U3 (300)')
        
        ax.scatter(20, 30, color='red')
        ax.annotate('(20,30)', (20+1, 30+1))
        
        ax.set_xlabel('Alimentos (A)')
        ax.set_ylabel('Vestido (V)')
        ax.set_title('Mapa de Curvas de Indiferencia')
        ax.legend()
        ax.grid(True)
        ax.set_xlim(0, 50)
        ax.set_ylim(0, 100)
        
        canvas = FigureCanvasTkAgg(fig, master=tab)
        canvas.draw()
        canvas.get_tk_widget().pack(side=tk.BOTTOM, fill=tk.BOTH, expand=True)
    
    def create_mrs_tab(self, notebook):
        """Pestaña sobre relación marginal de sustitución"""
        tab = ttk.Frame(notebook)
        notebook.add(tab, text="Relación Marginal de Sustitución")
        
        text = tk.Text(tab, wrap=tk.WORD, padx=10, pady=10)
        text.pack(fill='both', expand=True)
        
        content = """
RELACIÓN MARGINAL DE SUSTITUCIÓN (RMS)

Cantidad de Y a la que se renuncia por una unidad más de X, manteniendo la misma utilidad.

Fórmula:
RMS = - (UMg_X / UMg_Y)

Ejemplo con U = A*V:
- UMg_A = V
- UMg_V = A
- RMS = - (V/A)

La RMS es la pendiente de la curva de indiferencia en un punto.
"""
        text.insert(tk.END, content)
        text.config(state=tk.DISABLED)
        
        # Gráfico de ejemplo
        fig, ax = plt.subplots(figsize=(6, 4))
        A = np.linspace(10, 60, 100)
        V = 600 / A
        ax.plot(A, V, 'b-', label='U=600')
        
        # Puntos para mostrar RMS
        puntos = [(15, 40), (20, 30), (30, 20)]
        
        for a, v in puntos:
            rms = -v/a
            x_tang = np.linspace(a-10, a+10, 2)
            y_tang = v + rms*(x_tang - a)
            
            ax.plot(x_tang, y_tang, 'r--')
            ax.scatter(a, v, color='red')
            ax.annotate(f'RMS={rms:.1f}', (a+1, v+1))
        
        ax.set_xlabel('Alimentos (A)')
        ax.set_ylabel('Vestido (V)')
        ax.set_title('RMS en Diferentes Puntos')
        ax.legend()
        ax.grid(True)
        
        canvas = FigureCanvasTkAgg(fig, master=tab)
        canvas.draw()
        canvas.get_tk_widget().pack(side=tk.BOTTOM, fill=tk.BOTH, expand=True)
    
    def create_special_cases_tab(self, notebook):
        """Pestaña sobre casos especiales de preferencias"""
        tab = ttk.Frame(notebook)
        notebook.add(tab, text="Casos Especiales")
        
        text = tk.Text(tab, wrap=tk.WORD, padx=10, pady=10)
        text.pack(fill='both', expand=True)
        
        content = """
CASOS ESPECIALES DE PREFERENCIAS

1. Sustitutos Perfectos:
   - RMS constante (líneas rectas)
   - Ej: Zumo de naranja y manzana
   - Función: U(x,y) = ax + by

2. Complementarios Perfectos:
   - Forma de L (ángulos rectos)
   - Ej: Zapatos izquierdo y derecho
   - Función: U(x,y) = min(ax, by)

3. Males:
   - RMS positiva
   - Ej: Contaminación
   - Función: U(x,y) = ax - by
"""
        text.insert(tk.END, content)
        text.config(state=tk.DISABLED)
        
        # Gráfico de casos especiales
        fig, axs = plt.subplots(1, 3, figsize=(12, 4))
        
        # Sustitutos perfectos
        x = np.linspace(0, 10, 100)
        axs[0].plot(x, 10 - x, 'b-', label='U=10 (RMS=1)')
        axs[0].plot([0, 10], [0, 10], 'r-', label='Presupuesto (p1=p2=1, m=10)')
        axs[0].scatter(10, 0, color='green', label='Óptimo')
        axs[0].set_title('Sustitutos Perfectos')
        axs[0].set_xlabel('x')
        axs[0].set_ylabel('y')
        
        # Complementarios perfectos
        x = np.linspace(0, 12, 100)
        y1 = np.minimum(np.full_like(x, 5), x)  # U = min(x, y) = 5
        axs[1].plot(x, y1, 'b-', label='U=5')
        axs[1].plot([5, 5, 12], [0, 5, 5], 'b-')  # Línea vertical y horizontal
        axs[1].plot([0, 10], [0, 10], 'r-', label='Presupuesto (p1=p2=1, m=10)')
        axs[1].scatter(5, 5, color='green', label='Óptimo')
        axs[1].set_title('Complementarios Perfectos')
        axs[1].set_xlabel('x')
        axs[1].set_ylabel('y')
        
        # Males
        x = np.linspace(1, 10, 100)
        axs[2].plot(x, 10/x, 'b-', label='U=10')
        axs[2].plot([0, 10], [0, 10], 'r-', label='Presupuesto (p1=p2=1, m=10)')
        axs[2].scatter(10, 0, color='green', label='Óptimo')
        axs[2].set_title('Bien y Mal')
        axs[2].set_xlabel('Bien')
        axs[2].set_ylabel('Mal')
        
        for ax in axs:
            ax.grid(True)
            ax.legend()
            ax.set_ylim(0, 12)
            ax.set_xlim(0, 12)
        
        canvas = FigureCanvasTkAgg(fig, master=tab)
        canvas.draw()
        canvas.get_tk_widget().pack(side=tk.BOTTOM, fill=tk.BOTH, expand=True)
    
    def create_utility_functions_tab(self, notebook):
        """Pestaña sobre funciones de utilidad"""
        tab = ttk.Frame(notebook)
        notebook.add(tab, text="Funciones de Utilidad")
        
        text = tk.Text(tab, wrap=tk.WORD, padx=10, pady=10)
        text.pack(fill='both', expand=True)
        
        content = """
FUNCIONES DE UTILIDAD

Asignan valor numérico a cestas de mercado.

Tipos comunes:
1. Cobb-Douglas: U(x,y) = x^a y^b (preferencias convexas)
2. Sustitutos perfectos: U(x,y) = ax + by (RMS constante)
3. Complementarios: U(x,y) = min(ax, by) (forma de L)
4. Cuasilineal: U(x,y) = v(x) + by (una UM constante)
5. Logarítmica: U(x,y) = a ln(x) + b ln(y)
"""
        text.insert(tk.END, content)
        text.config(state=tk.DISABLED)
        
        # Gráfico de funciones de utilidad
        fig, axs = plt.subplots(2, 2, figsize=(10, 8))
        
        # Cobb-Douglas (U = x^0.2 * y^0.8)
        x = np.linspace(1, 20, 100)
        m, p1, p2 = 10, 1, 1  # Presupuesto m=10, p1=1, p2=1
        
        # Recta presupuestaria
        y_budget = (m - p1*x)/p2
        axs[0,0].plot(x, y_budget, 'r-', label='Presupuesto')
        
        # Punto óptimo (x = 2, y = 8)
        x_opt = 2
        y_opt = 8
        u_level = x_opt**0.2 * y_opt**0.8
        
        # Curva de indiferencia
        y_indiff = (u_level / x**0.2)**(1/0.8)
        axs[0,0].plot(x, y_indiff, 'b-', label=f'Indiferencia (U={u_level:.1f})')
        axs[0,0].scatter(x_opt, y_opt, color='green', label='Óptimo')
        axs[0,0].set_title('Cobb-Douglas: U = x^0.2 * y^0.8')
        
        # Sustitutos perfectos (U = x + y)
        x = np.linspace(0, 10, 100)
        axs[0,1].plot(x, 10 - x, 'b-', label='U=10')
        axs[0,1].plot([0, 10], [0, 10], 'r-', label='Presupuesto (p1=p2=1, m=10)')
        axs[0,1].scatter(10, 0, color='green', label='Óptimo')
        axs[0,1].set_title('Sustitutos Perfectos: U = x + y')
        
        # Complementarios perfectos (U = min(x,y))
        x = np.linspace(0, 12, 100)
        y = np.minimum(np.full_like(x, 5), x)  # U = min(x, y) = 5
        axs[1,0].plot(x, y, 'b-', label='U=5')
        axs[1,0].plot([5, 5, 12], [0, 5, 5], 'b-')  # Línea vertical y horizontal
        axs[1,0].plot([0, 10], [0, 10], 'r-', label='Presupuesto (p1=p2=1, m=10)')
        axs[1,0].scatter(5, 5, color='green', label='Óptimo')
        axs[1,0].set_title('Complementarios: U = min(x,y)')
        
        # Cuasilineal (U = x^2 + y)
        x = np.linspace(0.1, 4, 100)
        # Punto óptimo teórico: RMS = p1/p2 => 2x = 1/1 => x = 0.5
        x_opt = 0.5
        y_opt = 10 - 1*x_opt
        u_level = x_opt**2 + y_opt
        
        # Recta presupuestaria
        axs[1,1].plot(x, (10 - 1*x)/1, 'r-', label='Presupuesto')
        
        # Curva de indiferencia
        y_indiff = u_level - x**2
        axs[1,1].plot(x, y_indiff, 'b-', label=f'Indiferencia (U={u_level:.1f})')
        axs[1,1].scatter(x_opt, y_opt, color='green', label='Óptimo')
        axs[1,1].set_title('Cuasilineal: U = x^2 + y')
        
        for ax in axs.flat:
            ax.grid(True)
            ax.legend()
            ax.set_xlabel('x')
            ax.set_ylabel('y')
            ax.set_ylim(0, 12)
            ax.set_xlim(0, 12)
        
        plt.tight_layout()
        
        canvas = FigureCanvasTkAgg(fig, master=tab)
        canvas.draw()
        canvas.get_tk_widget().pack(side=tk.BOTTOM, fill=tk.BOTH, expand=True)
    
    def create_interactive_tab(self):
        """Pestaña interactiva para cálculos personalizados"""
        tab = ttk.Frame(self.main_notebook)
        self.main_notebook.add(tab, text="Calculadora")
        
        # Frame principal con scroll
        main_frame = ttk.Frame(tab)
        main_frame.pack(fill='both', expand=True)
        
        # Canvas y scrollbar
        canvas = tk.Canvas(main_frame)
        scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Variables para inputs
        self.function_type = tk.StringVar(value="Cobb-Douglas")
        self.utility_function_var = tk.StringVar(value="x**0.5 * y**0.5") # Default to Cobb-Douglas
        self.p1_var = tk.DoubleVar(value=1.0)
        self.p2_var = tk.DoubleVar(value=1.0) 
        self.m_var = tk.DoubleVar(value=100.0)
        self.p1_alt_var = tk.StringVar(value="")
        self.p2_alt_var = tk.StringVar(value="")
        self.m_alt_var = tk.StringVar(value="")
        
        # Widgets de entrada
        ttk.Label(scrollable_frame, text="Calculadora de Preferencias", 
                 font=('Helvetica', 14, 'bold')).grid(row=0, column=0, columnspan=3, pady=10)
        
        # Selección de tipo de función
        ttk.Label(scrollable_frame, text="Tipo de Función:").grid(row=1, column=0, sticky='e', padx=5, pady=5)
        function_menu = ttk.Combobox(scrollable_frame, textvariable=self.function_type,
                                    values=["Cobb-Douglas", "Sustitutos Perfectos", 
                                            "Complementarios Perfectos", "Cuasilineal", "Personalizada"])
        function_menu.grid(row=1, column=1, sticky='ew', columnspan=2, padx=5, pady=5)
        function_menu.bind("<<ComboboxSelected>>", self.update_function_example)
        
        # Función de utilidad con botones de operaciones
        ttk.Label(scrollable_frame, text="Función de Utilidad U(x,y):").grid(row=2, column=0, sticky='e', padx=5, pady=5)
        util_entry = ttk.Entry(scrollable_frame, textvariable=self.utility_function_var, width=40)
        util_entry.grid(row=2, column=1, sticky='ew', columnspan=2, padx=5, pady=5)
        self.utility_entry = util_entry # Store reference for inserting operations
        
        # Frame para botones de operaciones
        ops_frame = ttk.Frame(scrollable_frame)
        ops_frame.grid(row=3, column=0, columnspan=3, sticky='ew', pady=5, padx=5)
        
        # Botones de operaciones matemáticas
        operations = [
            ('^', '**'), ('√', 'sqrt('), ('e', 'exp(1)'), ('π', 'pi'), 
            ('ln', 'ln('), ('sin', 'sin('), ('cos', 'cos('), ('tan', 'tan('),
            ('min', 'Min('), ('max', 'Max('), ('+', '+'), ('-', '-'),
            ('*', '*'), ('/', '/'), ('(', '('), (')', ')')
        ]
        
        # Arrange buttons in rows
        num_cols = 6
        for i, (text, op) in enumerate(operations):
            btn = ttk.Button(ops_frame, text=text, width=5, 
                            command=lambda o=op: self.insert_operation(self.utility_entry, o))
            btn.grid(row=i//num_cols, column=i%num_cols, padx=1, pady=1, sticky='ew') 
        
        # Make buttons expand slightly
        for i in range(num_cols):
            ops_frame.grid_columnconfigure(i, weight=1)
        
        # Precios e ingresos (obligatorios)
        ttk.Label(scrollable_frame, text="Precios e Ingresos Obligatorios:", 
                 font=('Helvetica', 10, 'bold')).grid(row=4, column=0, columnspan=3, sticky='w', pady=10, padx=5)
        
        ttk.Label(scrollable_frame, text="Precio del Bien 1 (p₁):").grid(row=5, column=0, sticky='e', padx=5, pady=2)
        ttk.Entry(scrollable_frame, textvariable=self.p1_var, width=10).grid(row=5, column=1, sticky='w', padx=5, pady=2)
        
        ttk.Label(scrollable_frame, text="Precio del Bien 2 (p₂):").grid(row=6, column=0, sticky='e', padx=5, pady=2)
        ttk.Entry(scrollable_frame, textvariable=self.p2_var, width=10).grid(row=6, column=1, sticky='w', padx=5, pady=2)
        
        ttk.Label(scrollable_frame, text="Ingreso (m):").grid(row=7, column=0, sticky='e', padx=5, pady=2)
        ttk.Entry(scrollable_frame, textvariable=self.m_var, width=10).grid(row=7, column=1, sticky='w', padx=5, pady=2)
        
        # Precios e ingresos alternativos (opcionales)
        ttk.Label(scrollable_frame, text="Precios e Ingresos Opcionales:", 
                 font=('Helvetica', 10, 'bold')).grid(row=8, column=0, columnspan=3, sticky='w', pady=10, padx=5)
        
        ttk.Label(scrollable_frame, text="Precio alternativo p₁':").grid(row=9, column=0, sticky='e', padx=5, pady=2)
        ttk.Entry(scrollable_frame, textvariable=self.p1_alt_var, width=10).grid(row=9, column=1, sticky='w', padx=5, pady=2)
        
        ttk.Label(scrollable_frame, text="Precio alternativo p₂':").grid(row=10, column=0, sticky='e', padx=5, pady=2)
        ttk.Entry(scrollable_frame, textvariable=self.p2_alt_var, width=10).grid(row=10, column=1, sticky='w', padx=5, pady=2)
        
        ttk.Label(scrollable_frame, text="Ingreso alternativo m':").grid(row=11, column=0, sticky='e', padx=5, pady=2)
        ttk.Entry(scrollable_frame, textvariable=self.m_alt_var, width=10).grid(row=11, column=1, sticky='w', padx=5, pady=2)
        
        # Botón de cálculo
        ttk.Button(scrollable_frame, text="Calcular y Graficar", 
                  command=self.calculate_and_plot).grid(row=12, column=0, columnspan=3, pady=15)
        
        # Frame para resultados
        self.results_frame = ttk.Frame(scrollable_frame)
        self.results_frame.grid(row=13, column=0, columnspan=3, sticky='nsew', padx=10, pady=10) 
        
        # Configure row and column weights for scrollable_frame
        scrollable_frame.grid_columnconfigure(1, weight=1) # Allow center column to expand for entry fields
        for i in range(14): 
            scrollable_frame.grid_rowconfigure(i, weight=0) 
        scrollable_frame.grid_rowconfigure(13, weight=1) # Allow results_frame to expand
    
    def insert_operation(self, entry_widget, operation):
        """Inserta una operación matemática en el campo de entrada en la posición del cursor."""
        current_text = entry_widget.get()
        cursor_pos = entry_widget.index(tk.INSERT)
        
        text_to_insert = operation
        offset = len(operation)

        if operation.endswith('('):
            text_to_insert = operation + ')'
            offset = len(operation) # Cursor inside parenthesis
        elif operation == 'Min(' or operation == 'Max(':
            text_to_insert = operation + 'x, y)'
            offset = len(operation) + 4 # Cursor after 'x, '
        elif operation == '**':
            text_to_insert = '**' # Just insert **
            offset = 2
        elif operation == 'exp(1)':
            text_to_insert = 'exp(1)' # Just insert exp(1)
            offset = len('exp(1)')

        new_text = current_text[:cursor_pos] + text_to_insert + current_text[cursor_pos:]
        entry_widget.delete(0, tk.END)
        entry_widget.insert(0, new_text)
        entry_widget.icursor(cursor_pos + offset)

    def update_function_example(self, event=None):
        """Actualiza el ejemplo de función según el tipo seleccionado"""
        function_type = self.function_type.get()
        
        examples = {
            "Cobb-Douglas": "x**0.5 * y**0.5",
            "Sustitutos Perfectos": "x + y",
            "Complementarios Perfectos": "Min(x, y)",
            "Cuasilineal": "sqrt(x) + y",
            "Personalizada": "x*y" 
        }
        
        self.utility_function_var.set(examples.get(function_type, "x*y"))

    def preprocess_utility_string(self, utility_str):
        """
        Pre-procesa la cadena de utilidad para insertar '*' donde hay multiplicación implícita.
        Ej: '2x' -> '2*x', 'xy' -> 'x*y', 'x(y+1)' -> 'x*(y+1)'
        """
        # Add '*' between a digit and a variable/paren/function
        utility_str = re.sub(r'(\d)([a-zA-Z(])', r'\1*\2', utility_str)
        # Add '*' between a variable and a variable/paren/function
        utility_str = re.sub(r'([a-zA-Z)])([a-zA-Z(])', r'\1*\2', utility_str)
        
        # Add '*' after pi or e before a variable or parenthesis
        utility_str = re.sub(r'(pi|exp\(1\))([a-zA-Z(])', r'\1*\2', utility_str)
        
        # Add '*' before Min/Max/sqrt/ln if there's a preceding variable or number
        utility_str = re.sub(r'([0-9a-zA-Z\)])(Min|Max|sqrt|ln|sin|cos|tan)\(', r'\1*\2(', utility_str)
        
        # Handle cases like x(y+1) -> x*(y+1)
        utility_str = re.sub(r'([a-zA-Z])\(', r'\1*(', utility_str)

        return utility_str

    def calculate_and_plot(self):
        """Calcula y grafica según los inputs del usuario"""
        try:
            # Obtener valores obligatorios
            function_type = self.function_type.get()
            utility_fn_str_raw = self.utility_function_var.get()
            
            # Pre-procesar la cadena para manejar multiplicaciones implícitas
            utility_fn_str = self.preprocess_utility_string(utility_fn_str_raw)
            
            p1 = self.p1_var.get()
            p2 = self.p2_var.get()
            m = self.m_var.get()
            
            # Obtener valores opcionales
            p1_alt_val = self.p1_alt_var.get()
            p1_alt = float(p1_alt_val) if p1_alt_val else None
            
            p2_alt_val = self.p2_alt_var.get()
            p2_alt = float(p2_alt_val) if p2_alt_val else None
            
            m_alt_val = self.m_alt_var.get()
            m_alt = float(m_alt_val) if m_alt_val else None
            
            # Validar valores obligatorios
            if not utility_fn_str:
                raise ValueError("La función de utilidad es obligatoria.")
            if p1 <= 0 or p2 <= 0 or m <= 0:
                raise ValueError("Precios e ingreso deben ser positivos.")
            
            # Limpiar resultados anteriores
            for widget in self.results_frame.winfo_children():
                widget.destroy()
            
            # Preparar variables simbólicas
            x, y = symbols('x y')

            # Make sympy functions and numpy functions available in the eval scope
            global_vars_sympy = {
                'x': x, 'y': y, 'Min': Min, 'Max': Max, 'sqrt': sqrt, 
                'ln': ln, 'sin': sin, 'cos': cos, 'tan': tan, 'exp': exp, 'pi': pi,
                'E': exp(1), 'e': exp(1) # Map 'E' and 'e' to sympy.exp(1) for Euler's number
            }
            
            U = None
            try:
                U = sympify(utility_fn_str, locals=global_vars_sympy)
                # Check if U contains x or y, if not, it's a constant and makes no sense for ICs
                if not U.has(x) and not U.has(y):
                    raise ValueError("La función de utilidad debe depender de 'x' o 'y'.")
            except Exception as e:
                raise ValueError(f"Función de utilidad inválida o mal formateada. Asegúrese de usar 'x' y 'y' como variables, '**' para potencias, y 'Min(a,b)' para mínimo, etc. Error: {e}")
            
            # Calculate marginal utilities and RMS
            UMg_x_str = "N/A"
            UMg_y_str = "N/A"
            RMS_str = "N/A"

            is_perfect_complements = U.has(Min)
            
            is_linear_utility = False
            # Check if it's a linear function (ax + by) or ax - by
            try:
                # Test with x and y as powers of 1, and no other variables or complex functions
                test_U = U.subs({x: symbols('a_x'), y: symbols('a_y')}) 
                if test_U.is_Add: # U = term1 + term2 + ...
                    linear_terms = 0
                    for arg in test_U.args:
                        if arg.is_Mul: # Check for coefficients like 2*x, -3*y
                            coeff, var = arg.as_independent(symbols('a_x'), symbols('a_y'))
                            if var == symbols('a_x') or var == symbols('a_y'):
                                linear_terms += 1
                        elif arg == symbols('a_x') or arg == symbols('a_y'): # Check for x or y directly
                            linear_terms += 1
                    if linear_terms == 2: # Both x and y are linear terms
                        is_linear_utility = True
                elif test_U.is_Mul: # Covers cases like 'xy' or '2x'
                    if (test_U.has(symbols('a_x')) and not test_U.has(symbols('a_y')) and not test_U.has(Pow)) or \
                       (test_U.has(symbols('a_y')) and not test_U.has(symbols('a_x')) and not test_U.has(Pow)):
                        # This would be a single variable utility, like U=2x. Should be handled by general case.
                        pass
                    elif test_U.has(symbols('a_x')) and test_U.has(symbols('a_y')) and not test_U.has(Pow):
                        # Example: U=xy, not linear, so don't flag as perfect substitute.
                        # We specifically want ax+by type for perfect substitutes.
                        pass
            except:
                pass # Continue if symbolic analysis fails

            if is_perfect_complements:
                UMg_x_str = "Indeterminado (en el vértice)"
                UMg_y_str = "Indeterminado (en el vértice)"
                RMS_str = "Indeterminado (en el vértice)"
            elif is_linear_utility: # Perfect substitutes
                try:
                    UMg_x = diff(U, x)
                    UMg_y = diff(U, y)
                    UMg_x_str = str(UMg_x)
                    UMg_y_str = str(UMg_y)
                    
                    if UMg_y != 0:
                        RMS_val = Abs(simplify(UMg_x / UMg_y)) # RMS is usually positive
                        RMS_str = str(RMS_val)
                    else: # UMg_y is 0, implies utility only depends on x (vertical ICs), RMS is infinite
                        RMS_str = "Infinito (UMg_y es cero)"

                except Exception as e:
                    UMg_x_str = f"Error: {e}"
                    UMg_y_str = f"Error: {e}"
                    RMS_str = f"Error: {e}"
            else: # Cobb-Douglas, Quasilinear, or general differentiable functions
                try:
                    UMg_x = diff(U, x)
                    UMg_y = diff(U, y)
                    UMg_x_str = str(UMg_x)
                    UMg_y_str = str(UMg_y)
                    
                    if UMg_y != 0:
                        RMS_val = Abs(simplify(UMg_x / UMg_y)) # RMS is UMg_x / UMg_y (absolute value)
                        RMS_str = str(RMS_val)
                    else: # UMg_y is 0, implies utility only depends on x (vertical ICs), RMS is infinite
                        RMS_str = "Infinito (UMg_y es cero)"

                except Exception as e:
                    UMg_x_str = f"Error: {e}"
                    UMg_y_str = f"Error: {e}"
                    RMS_str = f"Error: {e}"

            # Determine number of plots and create figure
            configs_to_plot = [{"p1": p1, "p2": p2, "m": m, "label": "Original"}]
            if p1_alt is not None:
                configs_to_plot.append({"p1": p1_alt, "p2": p2, "m": m, "label": f"p₁'={p1_alt}"})
            if p2_alt is not None:
                configs_to_plot.append({"p1": p1, "p2": p2_alt, "m": m, "label": f"p₂'={p2_alt}"})
            if m_alt is not None:
                configs_to_plot.append({"p1": p1, "p2": p2, "m": m_alt, "label": f"m'={m_alt}"})
            
            num_plots = len(configs_to_plot)
            
            cols = 2 if num_plots > 1 else 1
            rows = (num_plots + cols - 1) // cols 
            
            fig, axs = plt.subplots(rows, cols, figsize=(10, 6 * rows))
            # Ensure axs is always a 2D array for consistent indexing
            if num_plots == 1:
                axs = np.array([[axs]]) 
            elif rows == 1 and cols > 1:
                axs = np.array([axs]) 

            # Global limits for plotting to ensure consistency across subplots
            max_x_overall = max([(conf["m"] / conf["p1"]) for conf in configs_to_plot]) * 1.2
            max_y_overall = max([(conf["m"] / conf["p2"]) for conf in configs_to_plot]) * 1.2
            max_x_overall = max(max_x_overall, 10) # Ensure a minimum scale
            max_y_overall = max(max_y_overall, 10)

            # Plot each configuration
            for i, config in enumerate(configs_to_plot):
                ax = axs[i//cols, i%cols]
                current_p1 = config["p1"]
                current_p2 = config["p2"]
                current_m = config["m"]
                current_label = config["label"]
                
                # Budget constraint
                x_max_budget = current_m / current_p1
                y_max_budget = current_m / current_p2
                
                x_budget_line = np.linspace(0, x_max_budget, 200)
                y_budget_line = (current_m - current_p1 * x_budget_line) / current_p2
                
                y_budget_line[y_budget_line < 0] = np.nan # Remove negative parts
                
                ax.plot(x_budget_line, y_budget_line, 'r-', label=f'Presupuesto {current_label}')
                ax.fill_between(x_budget_line, 0, y_budget_line, alpha=0.1, color='red') 
                
                x_opt_val = None
                y_opt_val = None
                u_level = None

                # Calculate optimal bundle and utility level based on function type or form
                if is_perfect_complements: # U = Min(ax, by)
                    try:
                        # Extract a and b from Min(ax, by)
                        a_comp = 1
                        b_comp = 1
                        if 'Min(' in utility_fn_str:
                            try:
                                # This is a very basic parser, may fail for complex expressions
                                content_in_min = utility_fn_str.split('Min(')[1].split(')')[0]
                                parts = content_in_min.split(',')
                                if len(parts) == 2:
                                    x_expr_str = parts[0].strip()
                                    y_expr_str = parts[1].strip()
                                    
                                    a_sym = sympify(x_expr_str.replace('x',''), locals=global_vars_sympy) if 'x' in x_expr_str else S.One
                                    b_sym = sympify(y_expr_str.replace('y',''), locals=global_vars_sympy) if 'y' in y_expr_str else S.One
                                    
                                    if a_sym.is_Number: a_comp = float(a_sym)
                                    if b_sym.is_Number: b_comp = float(b_sym)
                                    
                            except Exception as parse_e:
                                messagebox.showwarning("Advertencia", f"No se pudo parsear coeficientes de Min(). Usando a=1,b=1. Error: {parse_e}")
                                pass # Fallback to a=1, b=1 if parsing fails

                        # Optimal condition for perfect complements: ax = by AND p1x + p2y = m
                        # From ax = by, y = (a/b)x. Substitute into budget:
                        # p1x + p2(a/b)x = m
                        # x(p1 + p2*a/b) = m
                        # x = m / (p1 + p2*a/b) = m*b / (p1*b + p2*a)
                        x_opt_val = (current_m * b_comp) / (current_p1 * b_comp + current_p2 * a_comp)
                        y_opt_val = (current_m * a_comp) / (current_p1 * b_comp + current_p2 * a_comp)
                        
                        u_level = float(U.subs({x: x_opt_val, y: y_opt_val}))
                        
                        # Plot L-shaped indifference curve for perfect complements
                        x_corner = u_level / a_comp if a_comp != 0 else x_opt_val # If a_comp is 0, then U only depends on y. This case is less common.
                        y_corner = u_level / b_comp if b_comp != 0 else y_opt_val # If b_comp is 0, then U only depends on x.
                        
                        # Adjust corner slightly if it's very close to zero to avoid artifacts
                        if x_corner < 1e-6: x_corner = 0
                        if y_corner < 1e-6: y_corner = 0

                        ax.plot([x_corner, x_corner], [0, y_corner], 'b-') # Vertical part
                        ax.plot([0, x_corner], [y_corner, y_corner], 'b-', label=f'Indiferencia (U={u_level:.2f})') # Horizontal part
                        
                    except Exception as e:
                        messagebox.showwarning("Advertencia", f"No se pudo calcular el óptimo para Complementarios Perfectos. Verifique la función de utilidad. Error: {e}")
                
                elif is_linear_utility: # Perfect substitutes U = ax + by (or ax-by for bads)
                    try:
                        # Extract a and b from U = ax + by
                        a_sub = U.diff(x).subs({x:1, y:1}) # Evaluate UMg_x at a point to get coefficient
                        b_sub = U.diff(y).subs({x:1, y:1}) # Evaluate UMg_y at a point to get coefficient

                        if b_sub == 0: # Only depends on x (e.g., U=x or U=2x)
                            x_opt_val = current_m / current_p1
                            y_opt_val = 0
                        elif a_sub == 0: # Only depends on y
                            x_opt_val = 0
                            y_opt_val = current_m / current_p2
                        else:
                            # Compare RMS (a_sub/b_sub) with price ratio (current_p1/current_p2)
                            price_ratio = current_p1 / current_p2
                            rms_ratio = Abs(a_sub / b_sub) # Always positive for comparison
                            
                            if rms_ratio > price_ratio: # If MRS > Px/Py, consume only X
                                x_opt_val = current_m / current_p1
                                y_opt_val = 0
                            elif rms_ratio < price_ratio: # If MRS < Px/Py, consume only Y
                                x_opt_val = 0
                                y_opt_val = current_m / current_p2
                            else: # If MRS == Px/Py, any point on budget line is optimal
                                # For plotting, we can pick a midpoint or the entire line
                                x_opt_val = current_m / (2 * current_p1) 
                                y_opt_val = current_m / (2 * current_p2)
                                
                        u_level = float(U.subs({x: x_opt_val, y: y_opt_val})) if x_opt_val is not None and y_opt_val is not None else None

                        # Plot indifference curve for perfect substitutes
                        # y = (U_level - a_sub*x) / b_sub
                        x_values_indiff = np.linspace(0, max_x_overall, 300)
                        if b_sub != 0:
                            y_values_indiff = (u_level - float(a_sub) * x_values_indiff) / float(b_sub)
                            # Filter out non-real, negative, or excessively large values for plotting
                            y_values_indiff[(y_values_indiff < -1e-9) | (y_values_indiff > max_y_overall*2) | np.iscomplex(y_values_indiff)] = np.nan
                            ax.plot(x_values_indiff, y_values_indiff, 'b-', label=f'Indiferencia (U={u_level:.2f})')
                        else: # U only depends on x, e.g., U=x
                            if a_sub != 0:
                                ax.axvline(x=u_level/a_sub, color='b', linestyle='-', label=f'Indiferencia (U={u_level:.2f})')
                            else: 
                                messagebox.showwarning("Advertencia", "Función de utilidad constante detectada para Sustitutos Perfectos. No se puede graficar una curva de indiferencia significativa.")

                    except Exception as e:
                        messagebox.showwarning("Advertencia", f"No se pudo calcular el óptimo para Sustitutos Perfectos. Verifique la función de utilidad. Error: {e}")

                else: # Cobb-Douglas, Quasilinear, or general differentiable functions
                    try:
                        umg_x_func = diff(U, x)
                        umg_y_func = diff(U, y)
                        
                        # --- Logic for handling corner solutions, especially relevant for quasilinear ---
                        x_opt_val = None
                        y_opt_val = None
                        
                        # Case 1: Try interior solution (RMS = Px/Py)
                        try:
                            # Avoid division by zero if UMg_y is symbolically zero
                            if umg_y_func == 0:
                                raise ValueError("UMg_y es cero, implicando una solución de esquina o utilidad solo en X.")
                            
                            eq1 = Eq(umg_x_func / umg_y_func, current_p1 / current_p2)
                            eq2 = Eq(current_p1 * x + current_p2 * y, current_m)
                            
                            # Initial guess for nsolve
                            x_guess = current_m / (2 * current_p1)
                            y_guess = current_m / (2 * current_p2)
                            
                            sol = nsolve((eq1, eq2), (x, y), (x_guess, y_guess), verify=False)
                            x_sol_tentative = float(sol[0])
                            y_sol_tentative = float(sol[1])
                            
                            # If solution is non-negative, it's a valid interior solution
                            if x_sol_tentative >= -1e-9 and y_sol_tentative >= -1e-9: # Allow small neg for numerical stability
                                x_opt_val = max(0, x_sol_tentative)
                                y_opt_val = max(0, y_sol_tentative)
                            else:
                                raise ValueError("La solución de tangencia es negativa.") # Force corner solution logic

                        except Exception as nsolve_e:
                            # If nsolve fails or yields negative values, try corner solutions
                            # Evaluate utility at corners:
                            # Corner X (Y=0):
                            ux_at_corner = U.subs({x: current_m/current_p1, y: 0})
                            # Corner Y (X=0):
                            uy_at_corner = U.subs({x: 0, y: current_m/current_p2})
                            
                            # Check if the utility function becomes undefined at 0 (e.g., ln(0) or 1/0)
                            # Or if marginal utilities become extremely large/small
                            
                            umg_x_corner_val = None
                            umg_y_corner_val = None
                            try:
                                umg_x_corner_val = umg_x_func.subs({x: 1e-9, y: 1e-9}) # Evaluate close to origin
                                umg_y_corner_val = umg_y_func.subs({x: 1e-9, y: 1e-9})
                            except:
                                pass

                            if umg_y_corner_val is not None and umg_y_corner_val == 0: # UMg_y is zero, implies U depends only on x
                                x_opt_val = current_m / current_p1
                                y_opt_val = 0
                            elif umg_x_corner_val is not None and umg_x_corner_val == 0: # UMg_x is zero, implies U depends only on y
                                x_opt_val = 0
                                y_opt_val = current_m / current_p2
                            elif umg_x_corner_val is not None and umg_y_corner_val is not None:
                                # Compare marginal utility per dollar at corners (simplified check)
                                um_x_per_dollar = float(umg_x_corner_val) / current_p1
                                um_y_per_dollar = float(umg_y_corner_val) / current_p2

                                if um_x_per_dollar > um_y_per_dollar * 1.05: # X is significantly better per dollar
                                    x_opt_val = current_m / current_p1
                                    y_opt_val = 0
                                elif um_y_per_dollar > um_x_per_dollar * 1.05: # Y is significantly better per dollar
                                    x_opt_val = 0
                                    y_opt_val = current_m / current_p2
                                else: # If no clear corner, fallback to initial failure message
                                     messagebox.showwarning("Advertencia", f"Problema al encontrar solución. Detalles: {nsolve_e}")
                                     x_opt_val = 0 # Default to origin if no valid opt found
                                     y_opt_val = 0

                            else: # Cannot evaluate marginal utilities, fallback
                                messagebox.showwarning("Advertencia", f"Problema al encontrar solución. Detalles: {nsolve_e}")
                                x_opt_val = 0
                                y_opt_val = 0


                        # Calculate optimal utility level
                        if x_opt_val is not None and y_opt_val is not None:
                            u_level = float(U.subs({x: x_opt_val, y: y_opt_val}))
                        else:
                            u_level = None

                        # Plot indifference curve by finding y for various x values for the given u_level
                        if u_level is not None:
                            # Adjust x_values_indiff range dynamically and based on solution type
                            x_plot_min = 0.01 
                            x_plot_max = max(x_max_budget * 1.2, x_opt_val * 1.5 if x_opt_val is not None else 0, 10)
                            
                            # For quasilinear or specific cases, we might need a denser plot or adjusted start
                            if function_type == "Cuasilineal" or U.has(sqrt) or U.has(ln):
                                x_plot_min = 0.001 # Start very close to 0 to catch steep parts
                                x_plot_max = max(x_max_budget * 2, x_opt_val * 2 if x_opt_val is not None else 0, 20)
                                x_values_indiff = np.linspace(x_plot_min, x_plot_max, 500)
                            else:
                                x_values_indiff = np.linspace(x_plot_min, x_plot_max, 300)

                            y_values_indiff_plot = []
                            
                            for x_val in x_values_indiff:
                                try:
                                    # Solve U(x_val, y) = u_level for y
                                    y_sol = nsolve(Eq(U.subs(x, x_val), u_level), y, y_max_budget / 2) # Guess for y
                                    y_values_indiff_plot.append(float(y_sol))
                                except (TypeError, ValueError, Exception): # Catch errors from nsolve or if solution is non-real
                                    y_values_indiff_plot.append(np.nan)
                            
                            y_values_indiff_plot = np.array(y_values_indiff_plot)
                            
                            # Filter out non-real, negative, or excessively large values for plotting
                            y_values_indiff_plot[(y_values_indiff_plot < -1e-9) | (y_values_indiff_plot > max_y_overall*2) | np.iscomplex(y_values_indiff_plot)] = np.nan
                            
                            if not all(np.isnan(y_values_indiff_plot)):
                                ax.plot(x_values_indiff, y_values_indiff_plot, 'b-', label=f'Indiferencia (U={u_level:.2f})')
                            else:
                                messagebox.showwarning("Advertencia", "No se pudo graficar la curva de indiferencia para esta función. Verifique el nivel de utilidad o el rango.")

                        else:
                            messagebox.showwarning("Advertencia", "No se pudo determinar un nivel de utilidad óptimo para graficar la curva de indiferencia.")

                    except Exception as e:
                        messagebox.showwarning("Advertencia", f"Error al calcular o graficar el óptimo para función general: {e}\n"
                                                                "Asegúrese de que la función de utilidad es compatible con el cálculo de derivadas y solución numérica.")
                
                # Plot optimal point if found and valid
                if x_opt_val is not None and y_opt_val is not None and x_opt_val >= -1e-9 and y_opt_val >= -1e-9:
                    x_opt_val = max(0, x_opt_val) # Ensure non-negative display
                    y_opt_val = max(0, y_opt_val)
                    ax.scatter(x_opt_val, y_opt_val, color='green', s=100, zorder=5, label='Óptimo')
                    ax.annotate(f'({x_opt_val:.2f}, {y_opt_val:.2f})', 
                               (x_opt_val + max(x_max_budget*0.02, 0.5), y_opt_val + max(y_max_budget*0.02, 0.5)))
                else:
                    messagebox.showwarning("Advertencia", f"No se pudo encontrar un óptimo válido (x,y >= 0) para la configuración {current_label}.")

                
                ax.set_xlabel('Bien 1 (x)')
                ax.set_ylabel('Bien 2 (y)')
                ax.set_title(f'Configuración: {current_label}')
                ax.legend()
                ax.grid(True)
                ax.set_xlim(left=0, right=max_x_overall) 
                ax.set_ylim(bottom=0, top=max_y_overall)
                
            plt.tight_layout()
            
            # Create canvas with navigation toolbar
            canvas = FigureCanvasTkAgg(fig, master=self.results_frame)
            canvas.draw()
            
            toolbar = NavigationToolbar2Tk(canvas, self.results_frame)
            toolbar.update()
            
            canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)
            toolbar.pack(side=tk.TOP, fill=tk.X)
            
            # Display numerical results
            results_text = f"""
RESULTADOS:

Tipo de Función: {function_type}
Función de Utilidad: U(x,y) = {utility_fn_str_raw}
- UMg_x: {UMg_x_str}
- UMg_y: {UMg_y_str}
- RMS (UMg_x / UMg_y): {RMS_str}

"""
            if x_opt_val is not None and y_opt_val is not None and u_level is not None:
                 results_text += f"Óptimo del consumidor (x,y): ({x_opt_val:.2f}, {y_opt_val:.2f})\n"
                 results_text += f"Nivel de Utilidad Óptima (U): {u_level:.2f}\n"
            else:
                 results_text += "Óptimo del consumidor: No calculado o no aplicable para este tipo de función.\n"

            results_text += f"""
---
Configuración Original (p₁={p1}, p₂={p2}, m={m}):
- Pendiente Recta Presupuestaria: -{p1/p2:.2f}
- Máx x (si y=0): {m/p1:.2f}
- Máx y (si x=0): {m/p2:.2f}
"""
            # Add alternative configurations if they exist
            if p1_alt is not None:
                results_text += f"\nConfiguración p₁'={p1_alt} (p₂={p2}, m={m}):\n- Pendiente: -{p1_alt/p2:.2f}\n- Máx x: {m/p1_alt:.2f}\n"
            if p2_alt is not None:
                results_text += f"\nConfiguración p₂'={p2_alt} (p₁={p1}, m={m}):\n- Pendiente: -{p1/p2_alt:.2f}\n- Máx y: {m/p2_alt:.2f}\n"
            if m_alt is not None:
                results_text += f"\nConfiguración m'={m_alt} (p₁={p1}, p₂={p2}):\n- Máx x: {m_alt/p1:.2f}\n- Máx y: {m_alt/p2:.2f}\n"
            
            results_label = tk.Text(self.results_frame, wrap=tk.WORD, height=10)
            results_label.pack(side=tk.TOP, fill=tk.BOTH, expand=True, pady=(10,0)) 
            results_label.insert(tk.END, results_text)
            results_label.config(state=tk.DISABLED)
            
        except ValueError as e:
            messagebox.showerror("Error de Entrada", f"Entrada inválida: {str(e)}")
        except Exception as e:
            messagebox.showerror("Error Inesperado", f"Ocurrió un error inesperado: {str(e)}\n"
                                                      "Por favor, verifique el formato de su función de utilidad y los parámetros.")
            print(f"Error detallado: {e}") # For debugging

# Run the application
if __name__ == "__main__":
    root = tk.Tk()
    app = ConsumerTheoryApp(root)
    root.mainloop()
